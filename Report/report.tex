\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% bibliography package
\usepackage{csquotes} % ensures that babel cooperates with biblatex
\usepackage[backend=biber, style=alphabetic]{biblatex}
\addbibresource{sources.bib}

% Math packages
\usepackage{amsmath, amsthm, amsfonts, amssymb}
\usepackage{mathtools}
\usepackage{braket} % for quantum computing notation

% fixing braket definitions
\renewcommand{\bra}{\Bra}
\renewcommand{\ket}{\Ket}
\renewcommand{\braket}{\Braket}
\renewcommand{\set}{\Set}

% general formatting packages
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry} % for general document formatting (margins, indents etc)
\usepackage{enumerate} % allows control over style of po\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% bibliography package
\usepackage{csquotes} % ensures that babel cooperates with biblatex
\usepackage[backend=biber, style=alphabetic]{biblatex}
\addbibresource{sources.bib}

% Math packages
\usepackage{amsmath, amsthm, amsfonts, amssymb}
\usepackage{mathtools}
\usepackage{braket} % for quantum computing notation




% general formatting packages
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry} % for general document formatting (margins, indents etc)
\usepackage{changepage} % used to indent entire paragraphs
\usepackage{enumerate} % allows control over style of point in enumerate environment, as well as auto-detection
\usepackage{bookmark} % makes sections/subsections available in sidebar of pdf

% figure formatting packages
\usepackage{float} % allows strict placement of figures
\usepackage{graphicx} % for including and formatting figures
\usepackage{caption, subcaption} % for formatting captions on figures

% link formatting packages
\usepackage{hyperref} % for hyperlinking references within/without the document
\usepackage{xcolor} % allows custom colouring of hyperref links
\hypersetup{colorlinks,
                linkcolor={red!50!black},
                citecolor={blue!50!black},
                urlcolor={blue!50!black}} % define colours for hyperref links
\usepackage[nameinlink]{cleveref} % allows hyperref links to be modified/managed

% styling for various theorem environments
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}[section]

\makeatletter
\newtheoremstyle{centered}
        {\topsep}                                       % space above
        {\topsep}                                       % space below
        {\addtolength{\@totalleftmargin}{3.5em}         % body font
        \addtolength{\linewidth}{-3.5em}
        \parshape 1 3.5em \linewidth}
        {}                                              % indent amount
        {\bfseries}                                     % header font
        {.}                                             % header punctuation
        {\newline}                                      % space after theorem header
        {}                                              % theorem head specifications
\makeatother % all this just to indent definitions

\theoremstyle{centered}
\newtheorem{definition}{Definition}
\newtheorem{problem}{Problem}
\newtheorem{example}{Example}

% general formatting
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% fixing braket definitions
\renewcommand{\bra}{\Bra}
\renewcommand{\ket}{\Ket}
\renewcommand{\braket}{\Braket}
\renewcommand{\set}{\Set}
\newcommand{\camelia}{{\color{red}comment: }}

% general math commands for convenience
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\ceil}[1]{\left \lceil #1 \right \rceil}
\newcommand{\floor}[1]{\left \lfloor #1 \right \rfloor}
\newcommand{\inner}[2]{\left\langle #1, #2 \right\rangle}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\tensor}{\otimes}
\newcommand{\tr}[1]{\textnormal{tr}\left(#1\right)}
\renewcommand{\dim}[1]{\textnormal{dim}\left(#1\right)}
\newcommand{\conj}[1]{\overline{#1}}
\newcommand{\Cl}[1]{\textnormal{Cl}\left(#1\right)}
\newcommand{\gen}[1]{\left\langle #1 \right\rangle}
\newcommand{\vspan}[1]{\textnormal{span}\{#1\}}

\newcommand{\bb}[1]{\mathbb{#1}}
\renewcommand{\cal}[1]{\mathcal{#1}}

\title{The Hidden Subgroup Problem}
\author{River McCubbin\\[1cm]{\small Supervisor Camelia Karimian-Pour}}

\begin{document}
\maketitle

%\begin{abstract}
%Your abstract.
%\end{abstract}

\section{Introduction}\label{sec:introduction}
        This report discusses the coset sampling method as a quantum algorithm for solving the hidden subgroup problem through the lens of representation theory of groups. This approach is based on Maria Perepechaenko's master's thesis \cite{perepechaenko}.

\section{History and Background}\label{sec:history}

    In order to ease understanding of this report, we begin with this section discussing the relevant prerequisite materials and the history of the hidden subgroup problem. 
    These materials include linear algebra with a brief mention of elementary functional analysis, the basics of quantum computing, as well as some theory of groups and group representation theory.
    The aim of this section is to review and/or introduce these concepts at a level understandable to undergraduate students, with relevant examples to aid with more advanced concepts.

    \subsection{Linear Algebra}\label{history:linear_algebra}
        We suppose that a basic understanding of linear algebra is present, i.e. an understanding of vectors and a basic understanding of fields and their operations.
        With this background, we present the following relevant definitions and theorems:
        \begin{definition}[Hilbert Space]\label{def:hilbert_space}
            A vector space $\cal{H}$ is called a \textit{Hilbert space} if it is a complete inner product space, i.e. a vector space with an inner product such that any Cauchy sequence in $\cal{H}$ converges in $\cal{H}$ with respect to the inner product.
        \end{definition}
        When discussing quantum computing we work primarily in the space $\bb{C}^{2^n}$, which is a finite dimensional complex vector space.
        As such, we can find a basis for this space.
        Given a basis, we can denote our vectors as a list of coordinates and to concretely compute operations on our vectors.
        
%-----\camelia Even though, there is always a basis, finding it is not a trivial task, especially if your space is infinite-dimensional (which we will soon see it is not the case here) maybe "Given a basis for a Hilbert space, we can represent vectors in coordinates" -------
        
        We can also interact with vectors via various \textit{operators}.
        The most common type of operator is a \textit{linear} operator, defined as follows:

%------\camelia before the coming definition you need to tell your reading what you mean by $\bar{\cal{H}}$------

        
        \begin{definition}[Linear Operator]\label{def:linear_operator}
            A \textit{linear operator} $\phi : V \to W$ between two vector spaces over a field $\bb{F}$ is an operator satisfying $\phi(ax + by) = a\phi(x) + b\phi(y)$, for all $x, y \in V$ and $a, b \in \bb{F}$.
        \end{definition}
        Linear operators preserve the structure of a vector space, but not necessarily the the inner product, and hence not necessarily a notion of distance (norm).
        We can refine this definition to a new type of linear operator which does preserve the inner product of a vector space and hence the norm, called a \textit{unitary} operator:
        \begin{definition}[Unitary Operator]\label{def:unitary_operator}
            A linear operator $U : \cal{H} \to \cal{H}$ on a Hilbert space $\cal{H}$ is called \textit{unitary} if it preserves the norm, i.e. if it satisfies $\inner{U(x)}{U(y)} = \inner{x}{y}$.
            Another convenient fact about these operators is that they are \textit{self-adjoint}, i.e. they satisfy $UU^* = U^*U = I$ where $U^*$ is the conjugate transpose of $U$.
        \end{definition}

%-----\camelia I don't remember selfadjoint operators being used later in the text. If you don't need them, then no need to define them here. You can only focus on the unitary one and maybe say:``Generally a linear operator preserves the structure of the vector space but may not preserve the inner product. We are interested in those linear operators that do preserve the inner product, and hence the norm" and then you can give a definition of the unitary map that is only dependent to the inner product. ---------------------

        These operators provide the foundation of quantum computation, which is what we will see in \cref{history:quantum_computing}
        

    \subsection{Group Theory}\label{history:group_theory}
        
        The Hidden Subgroup Problem is a problem stated in the language of group theory. We will continue our discussion by going over some preliminary knowledge on groups and their instruction so that we can appropriately understand and discuss the HSP.

        \begin{definition}[Group]\label{def:group}
                A \textit{group} $G = (X, \cdot)$ is a set of elements $X$ along with an operation $\cdot$ on $X$,  such that the following properties hold:\footnote{the $\cdot $ is often omitted as concatenation, $a \cdot b = ab$
                }
                \begin{itemize}
                \item There exists an element $ e \in G$ such that $ae = ea = a$. This element is called the \textit{identity} element.
                \item $\forall a, b \in G$ we have that $ab \in G$.
%--------\camelia the second property is redundant. It is the property of having an operator on $X$----------
% RIVER: this is the definition given in Gallian. I know it's somewhat redundant but want to keep the definition as familiar as possible-

                
                \item $\forall a, b, c \in G$ we have that $(ab)c = a(bc)$.
                \item $\forall a \in G, \exists a^{-1} \in G$ such that $aa^{-1} = a^{-1} a = e$.
                \end{itemize}
        \end{definition}
        For this report we will restrict our discussion of groups to \textit{finite} groups.
        We denote the number of elements, or \textit{order}, of a group as $\abs{G}$.
        This notation also applies to subgroups.
        We use the same notation and terminology to denote the order of an element $g \in G$ where $\abs{g} = \min(\{n \mid g^n = e\})$.

%------\camelia maybe say a few words about what it means for a set to generate a group first, then it becomes easier to define $C_n$ and $D_{2n}$ through their generating set. -----------

        For a given group $G$, we can more concisely denote and classify a group by finding a \textit{generating set} for $G$.
        \begin{definition}[Generating Set]
                A \textit{generating set} for a group $G$ is a set of elements $\langle g_1, g_2, \dots, g_n \rangle$ such that any element of $G$ can be expressed as a combination of $g_i$.
        \end{definition}

        Along with a generating set, we can specify a group by the equations that hold with the group's operation and elements.
        For example the group of integers modulo 3, $\bb{Z}_3 = (\{0, 1, 2\}, +_{\mod 3})$, can be expressed as $\langle 1 \mid 3 = 0\rangle$.
        This \textit{generator expression} completely characterises this group; it contains all of the relevant information to distinguish this group from any other.

        With this way of describing groups we can discuss some particular types of group:
        \begin{definition}[Cyclic Group]
                A group $G$ is called \textit{cyclic} if $G = \{e, g, g^2, g^3 \dots g^{n-1}\} = \langle g \mid g^n = e \rangle$ for some element $g \in G$. 
                We denote such a group $C_n$ where $n$ is the number of elements in $G$.
        \end{definition}

        \begin{definition}[Dihedral Group]
                A group $G$ is called a \textit{dihedral group} if $G = \{e, r, r^2 \dots, r^{n-1}, s, sr, sr^2, \dots, sr^{n-1}\} = \langle r, s \mid r^n = s^2 = srsr = e \rangle$. 
                We denote the dihedral group of size $2n$ as $D_n$ or $D_{2n}$.
                This notation varies by author, and is typically clearly illustrated due to the prevalence of both of these notations.
                For this report, we will be using the notation $D_{2n}$ to represent the dihdedral group of size $2n$.
                The dihedral group of size $2n$ represents the symmetries of a regular $n$-gon.
        \end{definition}

        In any given group, we can have additional structures within that are not necessarily captured by these classifications.
        One such example of inner structure is a \textit{subgroup}:
        \begin{definition}[Subgroup]\label{def:subgroup}
                A \textit{subgroup} $H = (A, \cdot)$ of a group $G = (B, \cdot)$ is a group with the same operation as $G$ but fewer elements, $A \subseteq B$.
                If $H$ is a subgroup of $G$ then we write $H \leqslant G$ if it may be equal, and $H < G$ if $H \neq G$.
%--------\camelia introduces the subgroup notation $\leq$. You are about to use it in the next definition-------
        \end{definition}
        From subgroups we can generate \textit{cosets}, which will be particularly relevant to the discussion later on:
        \begin{definition}[Coset]\label{def:coset}
                A \textit{coset} of a subgroup $H \leqslant G$ is the set $a \cdot H = \{a \cdot h \mid h \in H\}$. If $G$ is non-abelian then we differentiate the \textit{left} coset as defined above, and the \textit{right} coset $Ha = \{h \cdot a \mid h \in H\}$.
        \end{definition}

%-----\camelia  def below can come right after the definition of groups. It doesn't need definiiton enviroment. And right there you can restrict yourself to finite groups. --------

        We complete our review of group theory with a brief mention of morphisms (functions) on groups.

%-----\camelia again tell the reader what $\Bar{G}$ means. This is not a common use of $\bar{}$. Maybe call them $G$ and $K$ --------
%RIVER: this notation is borrowed from Gallian, but i agree that it can be confusing

        
        \begin{definition}[Homomorphism]\label{def:homomorphism}
                A function $f: G \to K$ between groups $G$ and $K$ is called a \textit{homomorphism} if $f(ab) f(a)f(b)$ for all $a, b \in G$.
        \end{definition}

        \begin{definition}[Isomorphism]\label{def:isomorphism}
                A function $f: G \to K$ between groups $G$ and $K$ is called an \textit{isomorphism} if $f$ is a bijective homomorphism.
        \end{definition}

        These types of functions provide a convenient way of comparing the structure of groups.
        
    \subsection{Basics of Quantum Computing}\label{history:quantum_computing}
        With the appropriate background in linear algebra and group theory, we begin our discussion of quantum computing.
        The foundation of quantum computing are \hyperref[def:hilbert_space]{Hilbert spaces}, defined in \hyperref[history:linear_algebra]{section 2.1}.
        In the context of quantum computing, we call the Hilbert space in which we work our \textit{state space}.\\
        As mentioned in \hyperref[history:linear_algebra]{Section 2.1}, we typically work with $\cal{H} = \bb{C}^{2^n}$.

    
        We first introduce some terminology.
        \begin{definition}[Computational Basis]\label{def:computational_basis}
            The \textit{computational basis} is an orthonormal basis for $\cal{H}$, and is assumed to be equivalent to the standard basis unless stated otherwise.
        \end{definition}
%-------- \camelia maybe first say that the Hilbert space you work with is $\bb{C}^{2^n}$, and then unless otherwise stated your choice of computational basis is the standard basis. Say this outside of the definition environment. --------------

        \begin{definition}[Qubit]\label{def:qubit}
            A \textit{qubit} is a unit vector in $\bb{C}^n$, i.e. a vector with length 1.
        \end{definition}
        These are simply new terms for objects that we have already seen; the computational basis will be the name we give the standard basis and a qubit is the name that we give a unit vector in $\bb{C}^n$.

%--------\camelia Tell the reader how to interpret ket and bra notation here before using them. Also tell the reader what $|j>$ means ($j$-th standard vector)--------------
        
        For example, in $\bb{C}^2$ we take $\cal{B} = \{\ket{0} = (1,0), \ket{1} = (0, 1)\}$ to be the computational basis.
        
        %We can create higher dimensional bases, and by extension higher dimensional state vectors, by taking the \textit{tensor product} of each underlying qubit.
        Of course, computing on a single qubit is practically useless; we require many bits in order to represent most data of interest.
        We can construct higher dimensional spaces (spaces with more qubits) by taking the \textit{tensor product} of smaller spaces.
        We can extend this further; if we wish to compute on multiple pieces of data we can construct spaces to represent each of them, and take the tensor product of their respective spaces in order to generate a space capable of representing them simultaneously.

%---------------\camelia rephrases the sentence above. Maybe : in quantum algorithms, we often need to work with multiple state spaces at the same time. Mathematically, this translates into working with the tensor product of multiple Hilbert spaces. ---------------

        
        \begin{definition}[Tensor Product]\label{def:tensor_product}
            Let $V$ and $W$ be two vector spaces with bases $\cal{B}_V$ and $\cal{B}_W$ respectively, both over a field $\bb{F}$.
            Given 
                $$v = \sum_{v_i \in \cal{B}_V} a_i v_i \in V$$ 
            and 
                $$w = \sum_{w_j \in \cal{B}_W} b_j w_j \in W$$
            with $a_i, b_j \in \bb{F}$, we define the \textit{tensor product} 
                $$v \otimes w = \sum_{v_i \in \cal{B}_V} \sum_{w_j \in \cal{B}_W} (a_i b_j) (v_i \otimes w_j)$$
            where $(v_i \otimes w_j)$ is notation for a basis vector in $V \otimes W$.
        \end{definition}
        For example, in a two-qubit system we generate the computational basis by taking $\ket{0} \tensor \ket{0}, \ket{0} \tensor \ket{1}, \ket{1} \tensor \ket{0}, \ket{1} \tensor \ket 1$.
        Since this operation is so common in quantum computing, we often abbreviate this notation as follows: $\ket{ab} := \ket{a} \tensor \ket{b}$.
        We further simplify this for computational basis vectors, where we denote the first basis vector (the vector with a 1 in the first position and 0s elsewhere) as $\ket{0}$, regardless of the dimension of the space.
        We denote the second basis vector as $\ket{1}$, the third as $\ket{2}$, and in general the $n$th basis vector as $\ket{n-1}$.

        We can verify that these tensor product do in fact generate bases for higher dimensions as follows:
        
        \begin{theorem}
            $\bb{C}^{2^n} \otimes \bb{C}^{2^n} = \bb{C}^{2^{2n}}$.
        \end{theorem}
%----\camelia  $\bb{C}^{2n}$?-----
        \begin{proof}
                We can prove this by verifying that the set of pairwise tensor products of basis elements for $\bb{C}^{2^n}$ generates a basis for $\bb{C}^{2^{2n}}$.
            We give here a simple example, as the general proof requires knowledge of functional analysis beyond the scope of this report.

            Consider the computational basis $\cal{B} = \{\ket{0}, \ket{1}\}$ for $\bb{C}^2$.\\
            We will increase the dimension of our state space by taking $\bb{C}^2 \otimes \bb{C}^2 = \bb{C}^4$.\\
            Computing taking the tensors of our basis we find:
            \begin{align*}
            \ket{0} \tensor \ket{0} & & \ket{0} \tensor \ket{1}\\
            &= \begin{bmatrix} 1 \\ 0 \end{bmatrix} \tensor \begin{bmatrix} 1 \\ 0 \end{bmatrix} & &= \begin{bmatrix} 1 \\ 0 \end{bmatrix} \tensor \begin{bmatrix} 0 \\ 1 \end{bmatrix}\\
            &= \begin{bmatrix} 1 & \begin{bmatrix} 1 \\ 0 \end{bmatrix} \\ 0 & \begin{bmatrix} 1 \\ 0 \end{bmatrix} \end{bmatrix} & &= \begin{bmatrix} 1 & \begin{bmatrix} 0 \\ 1 \end{bmatrix} \\ 0 & \begin{bmatrix} 0 \\ 1 \end{bmatrix} \end{bmatrix}\\
            &= \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix} & &= \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}
            \end{align*}

            \begin{align*}
            \ket{1} \tensor \ket{0} & & \ket{1} \tensor \ket{1}\\
            &= \begin{bmatrix} 0 \\ 1 \end{bmatrix} \tensor \begin{bmatrix} 1 \\ 0 \end{bmatrix} & &= \begin{bmatrix} 0 \\ 1 \end{bmatrix} \tensor \begin{bmatrix} 0 \\ 1 \end{bmatrix}\\
            &= \begin{bmatrix} 0 & \begin{bmatrix} 1 \\ 0 \end{bmatrix} \\ 1 & \begin{bmatrix} 1 \\ 0 \end{bmatrix} \end{bmatrix} & &= \begin{bmatrix} 0 & \begin{bmatrix} 0 \\ 1 \end{bmatrix} \\ 1 & \begin{bmatrix} 0 \\ 1 \end{bmatrix} \end{bmatrix}\\
            &= \begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \end{bmatrix} &&= \begin{bmatrix} 0 \\ 0 \\ 0 \\ 1 \end{bmatrix}
            \end{align*}
            which generates a basis for $\bb{C}^{4}$, as wanted.
        \end{proof}

        In quantum computing, we represent \hyperref[def:state_vector]{states} by column vectors, denoted by the ``ket" symbol $\ket{\psi}$ (read ``ket psi").
        We use the ``bra" symbol $\bra{\psi}$ (read ``bra psi") to denote the \hyperref[def:linear_operator]{linear operator} $\bra{\psi} : \cal{H} \to \bb{C}$, the \hyperref[def:adjoint_operator]{adjoint} of $\ket{\psi}$.
        In essence, this notation is simply a convenient way of writing column vectors ($\ket{\psi}$) and row vectors ($\bra{\psi}$). This notation may seem odd, but when put together we can see why it is useful; $\bra{\psi} \ket{\phi} = \braket{\psi | \phi}$ denotes the result of $\phi$ under the map $\psi$, which is conveniently given by their inner product $\inner{\psi}{\phi}$.

        
        Given a basis, we can then discuss a \textit{state vector}.
        \begin{definition}[State Vector]\label{def:state_vector}
            A \textit{state vector} $\ket{\psi} \in \bb{C}^{2^n}$ is a $2^n$-dimensional unit vector where $n$ is the number of \hyperref[def:qubit]{qubits} in the system.
            It represents the state of all qubits in the system, and is given by $\ket{\psi} = a \ket{0} + b \ket{1} + \dots + c \ket{2^n - 1}$.
        \end{definition}

        With our current knowledge we can construct an $n$-bit system, and represent a state by a vector in $\bb{C}^{2^n}$. We now begin a discussion of actual computation; the above is simply the necessary information to set up our system.

        In order to compute we apply operations to our state. As mentioned, we require that a state be represented by a unit vector; in order to progress from one state to the next, we will require that any operations output only unit vectors. Such operations within a vector space such as $\bb{C}^{2^n}$ are called \hyperref[def:unitary_operator]{unitary operators}, as described in \hyperref[history:linear_algebra]{Section 2.1}.
        These unitary operators can be applied to act as logical operations, called ``logic gates" in the language of computer science. Using these logic gates we can create quantum circuits that are similar to classical circuits, allowing us to perform logical operations such as AND, OR, NOT etc.
        For example, we can construct the quantum equivalent of the NOT gate, called the Pauli-X gate. 
        This gate is given by the following matrix:
            $$\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}$$
        We can verify that this in fact negates a given qubit:
        \begin{align*}
            \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix} \ket{0} &= \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} 1 \\ 0 \end{bmatrix}& \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix} \ket{1} &= \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} 0 \\ 1 \end{bmatrix}\\
            &= \begin{bmatrix} 0 \\ 1 \end{bmatrix} & &= \begin{bmatrix} 1 \\ 0 \end{bmatrix}
        \end{align*}
        You may notice that this is in fact a rotation matrix, particularly about the $X$-axis, hence the name Pauli-X gate.
        There are corresponding Pauli-$Y$ and $Z$ gates that represent rotations about other axes.
        
        Unfortunately, though, it is not possible to create a universal gate, such as NAND, or NOR.
        This means that for quantum computation, most circuits need to be custom built for the operations we want to run.
%TODO custom built is quite informal
        Once we have completed the computation we desire by applying unitary operators, we require a way of measuring the system in order to retrieve the information we have computed.
        This requires what are called \textit{measurement operators}.
%TODO what does measurement really mean?
        \begin{definition}[Measurement Operators]\label{def:measurement_operator}
            A collection $\{M_m\}$ of \textit{measurement operators} is a set of operators satisfying $$\sum_m M_m^* M_m = I.$$ 
            These operators act on the state space, where the index $m$ represents the measurement outcomes that could occur. 
            If the state of the system before measurement is $\psi$, then the probability result $m$ occurs is given by $$p(m) = \bra{\psi}M_m^* M_m \ket{\psi}$$ and the state after measurement is given by $$\frac{M_m \ket{\psi}}{\sqrt{p(m)}}$$
        \end{definition}
        An example of a set of measurement operators is the set of projection matrices in $\bb{C}^{2^n}$.
%TODO maybe include example here

    \subsection{Representation Theory of Groups}\label{history:representation_theory}
        We continue our necessary background with an introduction to representation and character theory.
        The discussion of this topic is what permits the application of the \hyperref[def:general_QFT]{Quantum Fourier Transform}, the algorithm that permits quantum computing to solve problems such as the hidden subgroup problem more efficiently than classical computers.
%TODO discuss shor's algorithm and other quantum computing background
        To begin, we define the concept of a \textit{representation} of a group $G$.
        \begin{definition}[Representation]\label{def:representation}
            A representation $\rho$ of a group $G$ is a homomorphism $\rho : G \to GL(V)$ for some finite dimensional vector space $V$. Here, $GL(V)$ denotes the general linear group of the vector space $V$, the set of invertible matrices on $V$.
        \end{definition}
%TODO maybe use equivalent instead of isomorphic

        We think of a representation as a map that treats group elements of $G$ as functions acting on $V$.

        \begin{definition}[Isomorphic Representations]\label{def:isomorphic_representations}
            Two representations $\rho_1: G \to GL(V), \rho_2: G \to GL(W)$ of a group $G$ are called \textit{isomorphic} if there exists an isomorphism $\phi :V \to W$ such that $\phi(\rho_1(g)(v)) = \rho_2(g)(\phi(v)), \forall v \in V, \forall g \in G$.
        \end{definition}

        \begin{definition}[Character]\label{def:character}
            The \textit{character} $\chi$ of a representation $\rho: G \to GL(V)$ of a group $G$ is the map $\chi: G \to \bb{C}$ given by $\chi(g) = \tr{\rho(g)}$.
        \end{definition}

        We define an inner product on functions on $G$ by
            $$ \inner{f}{h} = \frac{1}{\abs{G}}\sum_{g \in G} f(g) \conj{h(g)}.$$

        \begin{definition}[Irreducible Representation]\label{def:irrep}
            A representation is said to be \textit{irreducible} if there are no non-trivial subspaces $W \subset V$ such that $\rho(g)W \subset W, \forall g \in G$. The \hyperref[def:character]{character} of an irreducible representation is called an \textit{irreducible character}.
        \end{definition}

%TODO re-word using less notation
%TODO instead of equal use isomorphic
        \begin{theorem}[Schur's Lemma]\label{thm:schurs_lemma}
            Given irreducible representations of $G$ $\rho_1: G \to GL(V)$ and $\rho_2: G \to GL(W)$ then for $\phi: GL(V) \to GL(W)$ satisfying $\rho_2(\phi(g)) = \phi(\rho_1(g))$ we have the following:
                \begin{enumerate}
                \item If $\rho_1$ and $\rho_2$ are not isomorphic then $\phi = 0$.
                \item If $V = W$ and $\rho_1 = \rho_2$ then $\phi$ is a scalar multiple of the identity.
                \end{enumerate}
        \end{theorem}
        \begin{proof}
            The proof of this is given in \cite{serre}.
        \end{proof}

%TODO phi should be an intertwining operator
        \begin{theorem}[Corollary to Schur's Lemma]
            If $\phi: V \to W$ is a linear map such that 
                $$h = \frac{1}{\abs{G}} \sum_{g \in G} \left(\rho_2(g)\right)^{-1}\phi \rho_1(g)$$
            then:
                \begin{enumerate}
                \item If $\rho_1$ and $\rho_2$ are not isomorphic then $h = 0$.
                \item If $V = W$ and $\rho_1 = \rho_2$ then $h = \frac{\tr{\phi}}{\dim{V}} I$.
                \end{enumerate}
        \end{theorem}
        \begin{proof}
            The proof of this is given in \cite{serre}.
        \end{proof}

%TODO refer back to inner product
%TODO maybe switch theorem and explanation afterwards (characters are orthonormal is theorem, to prove this use what is in the theorem rn and refer to serre)
        \begin{theorem}\label{thm:serre15} % page 15 in serre
            \begin{enumerate}
            \item If $\chi$ is the character of an irreducible representation then $\inner{\chi}{\chi} = 1$.
            \item If $\chi$ and $\chi'$ are the characters of two non-isomorphic irreducible representations then $\inner
{\chi}{\chi'} = 0$.
            \end{enumerate}
        \end{theorem}
        \begin{proof}
            The proof of this is given in \cite{serre}.
        \end{proof}
        This effectively tells us that the set of irreducible characters on $G$, denoted $\hat{G}$, forms an orthonormal set.

%TODO this means that f is constant on conjugacy classes, also add forall g,h in G
        \begin{definition}[Class Function]\label{def:class_function}
            A function $f : G \to V$ is called a \textit{class} function if $f(hgh^{-1}) = f(g)$.
        \end{definition}

        \begin{definition}[Conjugate Representation]\label{def:dual_representation}
            For a representation $\rho: G \to GL(V)$, the \textit{dual representation} $\rho^*: G \to GL(V^*)$ is given by
                $$\rho^*(g) = \conj{\rho(g^{-1})}.$$
        \end{definition}

%TODO fix this
        \begin{theorem}\label{thm:irr-conj}
            The conjugate of an irreducible representation is irreducible.
        \end{theorem}
        \begin{proof}
            First consider the following:
            \begin{align*}
            \rho^*(g)\rho^*(h) &= \conj{\rho(g^{-1})} \conj{\rho(h^{-1})} & \text{by definition \ref{def:dual_representation}}\\
            &= \conj{\rho(h^{-1})\rho(g^{-1})} & \text{by definition of conjugate}\\
            &= \conj{\rho(hg)^{-1}} & \text{since $\rho$ is a homomorphism}\\
            &= \rho^*(gh).
            \end{align*}
            This shows that $\rho^*$ is a homomorphism from $G$ to $GL(V^*)$ and hence a representation.\\
            Since eigenvalues are preserved by transpose we have that $\rho(g^{-1})$ and $\rho^*(g)$ have the same eigenvalues.\\
            Since $\chi_{\rho^*}(g) = \tr{\rho^*(g)}$ we have that it is the sum of eigenvalues of $\rho^*(g) = \rho(g^{-1})$ and hence is an irreducible character, as wanted.
        \end{proof}

        \begin{theorem}\label{thm:irr_characters}
            For a given group $G$, the set $\hat{G} = \{\chi_0. \dots, \chi_{N-1}\}$ of all irreducible characters of $G$ forms an orthonormal basis for the space of class function on $G$.
        \end{theorem}
        \begin{proof}
            As shown in \cref{thm:serre15}, we know that this set is orthonormal. It remains to show that it forms a basis, i.e. that this set spans $\text{Cl}(G)$.

            Let $\rho$ be an irreducible representation of $G$.\\
            Let $f \in \Cl{G}$ and suppose that it is orthogonal to every irreducible character of $G$, i.e. it is not in the span of these characters.\\
            We define the map 
                $$\rho_f = \sum_{g \in G} f(g) \rho(g)$$
            from $V$ into itself.

            Let $g' \in G$ be arbitrary.\\
            Then:
            \begin{align*}
            \rho_f(\rho(g')) &= \sum_{g \in G} f(g) \rho(g) \rho(g') & \text{by definition of $\rho_f$}\\
            &= \sum_{g \in G} f(g) \rho(gg') & \text{since $\rho$ is a homomorphism}\\
            &= \sum_{g \in G} f(g) \rho(g'(g')^{-1} g g') & \text{multiplying by $g'(g')^{-1} = e)$}\\
            &= \sum_{g \in G} f(g) \rho(g') \rho((g')^{-1} g g') & \text{since $\rho$ is a homomorphism}\\
            &= \rho(g') \sum_{g \in G} f(g) \rho((g')^{-1} g g') & \text{since $\rho(g')$ does not depend on $g$}\\
            &= \rho(g') \sum_{g \in G} f(g' ((g')^{-1} g g') (g')^{-1}) \rho((g')^{-1} g g')\\
            &= \rho(g') \sum_{g \in G} f((g')^{-1} g g') \rho((g')^{-1} g g') & \text{since $f$ is a class function}\\
            &= \rho(g') \rho_f & \text{by definition of $\rho_f$}
            \end{align*}
            This show that $\rho_f$ satisfies the requirements of Schur's Lemma, and since $\rho$ is irreducible we have that $\rho_f$ is a scalar multiple of the identity.

            Since $\rho_f = \lambda I$ we have that $\tr{\rho_f} = \lambda d$ where $d$ is the degree of $\rho$.
            By definition we have that $\tr{\rho(g)} = \chi(g)$, hence
            \begin{align*}
            \tr{\rho_f} &= \tr{\sum_{g \in G} f(g) \rho(g)}\\
            &= \sum_{g \in G} f(g) \chi_{\rho}(g) & \text{by definition of $\chi_\rho$}\\
            &= \abs{G}\inner{f}{\conj{\chi}} &\text{by definition of inner product}
            \end{align*}

            Since $\rho$ is irreducible by \cref{thm:irr-conj} we have that so is $\conj{\rho}$ and hence $\conj{\chi}$ is an irreducible character.\\
            This means that this inner product is zero, and hence $\lambda = 0$.\\
            Hence for any irreducible representation, $\rho_f = 0$.
        \end{proof}
        
        Notice that for abelian groups the set of class functions on $G$, denoted $\Cl{G}$ is equivalent to the set of all complex valued functions on $G$, $\bb{C}^G$. This fact is important in our construction and application of the \hyperref[def:general_QFT]{Quantum Fourier Transform}, as the transform applies a change of basis and this will be the basis we choose.

        Unfortunately, this is not the case for non-abelian groups, and hence the same construction does not suffice. 
        Instead of using the characters of irreducible representations as an orthonormal basis for the class functions, for non-abelian finite groups we proceed as follows:
        \begin{adjustwidth}{3.5em}{}
        Determine the set of all irreducible representations $\rho_i$ of $G$. 
        We choose a basis $\cal{B}$ for each representation such that the matrix $M_\rho(g) = (\rho_{ij}(g))_{i,j}$ is unitary for each $g \in G$. 
        We call the entries of these matrices the matrix coefficients of $\rho$ with respect to the chosen basis $\cal{B}$. 
        These matrix coefficients define functions from $G \to \bb{C}$, and furthermore form an orthogonal basis for $\bb{C}^G$. 
        By normalizing we find an orthonormal basis for $\bb{C}^G$. 
        Proof of this can be found in \cite{perepechaenko} and \cite{serre}.
        \end{adjustwidth}
        We will formalize this important result as a theorem for future reference:
        \begin{theorem}\label{thm:matrix_coefficients}
                If $G$ is a finite group, then a basis can be chosen such that the matrix $M_\rho(g)$ is unitary. The set of these coefficients forms an orthogonal basis for $\bb{C}^G$, and the set $\{\sqrt{\textnormal{dim}(\rho)} (\rho, i, j)\}$ where $(\rho, i, j)$ is the $i,j$th coefficient of the matrix $M_\rho(g)$ is an orthonormal basis for $\bb{C}^G$.
        \end{theorem}

    \subsection{The Quantum Fourier Transform}\label{history:QFT}

        With the appropriate background and a basis for $\bb{C}^G$, we can now define the general @quantum fourier transform.
        This transform, as alluded to in \hyperref[history:representation_theory]{Section 2.2}, is a change of basis formula.
        In particular, the basis we change to is generated by the irreducible representations of a group $G$, and is invariant under the group actions of $G$, i.e. if $\ket{i}$ is a basis vector then $\rho(g)(\ket{i}) \in \textnormal{span}\{\ket{i}\}$.
        
        As mentioned at the end of the previous section, the basis differs based on whether we have an abelian group.
        For abelian groups, we obtain the formula
        \begin{equation}\label{def:abelian_QFT}
            \cal{F}_G(\ket{g}) = \frac{1}{\sqrt{\abs{G}}} \sum_{i=0}^{\abs{G}} \chi_i(g) \ket{\chi_i}.
        \end{equation}
        using the basis of irreducible characters of $G$, which is an orthonormal basis for $\bb{C}^G$ by theorem \ref{thm:irr_characters}.

        For general non-abelian groups we recall from that the set of irreducible characters is not a basis for $\bb{C}^G$, but invoking theorem \ref{thm:matrix_coefficients} we can use the set of scaled matrix coefficients as a basis, giving the \textit{general Quantum Fourier Transform}:
        \begin{equation}\label{def:general_QFT}
        \cal{F}_G(\ket{g}) = \frac{1}{\sqrt{\abs{G}}} \sum_{\sigma \in \hat{G}} \sqrt{\dim{\sigma}} \sum_{i,j = 1}^{\dim{\sigma}} \sigma(g)_{i,j} \ket{\sigma, i, j}
        \end{equation}
        where $\ket{\sigma, i, j}$ denotes the map from $GL(V) \to \bb{Z}$ taking a group element $g$ to it's matrix coefficient at $i, j$ under $\sigma$, or more concisely $\ket{\sigma, i, j}(g) = \bra{i}\sigma(g) \ket{j}$.

        Notice that for the case of abelian groups the general QFT is equivalent to that of the ablian QFT; the representations are all of dimension 1 and hence the matrices are $1 \times 1$, meaning that the second sum in the general QFT disappears and we obtain the abelian case.
        Thanks to this, when we discuss the quantum fourier transform in the future we will discuss only the general case unless stated otherwise.

        Referring back to \hyperref{history:quantum_computing}[Section 2.2] we recall that any transformation we apply must be unitary.
        Fortunately for us, QFT is a unitary transform:
        \begin{theorem}
                The quantum fourier transform is a unitary transformation.
        \end{theorem}
        \begin{proof}
                A formal proof of this can be found in \cite{perepechaenko}, but we provide an intuitive argument here.
                Notice that the general quantum fourier transform is a tranformation from an orthonormal basis to an orthonormal basis.
                This means that, at the very least, $\cal{F}$ preserves the norm of unit vectors, which is sufficient for our purposes.
        \end{proof}
        

        This definition can appear intimidating, and so we now examine an example of applying the quantum fourier transform, based on \cite{hadfield}.
        \begin{example}
            We consider a simple example using the group $\bb{Z}_2$ and denote the elements of this group by the vectors $\ket{0}$ and $\ket{1}$ and operation given by $\ket{i} + \ket{j} = \ket{i + j \mod 2}$. The state space we take to be $\bb{C}^2 = \bb{C}\bb{Z}_2$.
            For this group we have two irreducible representations, given by
                $$\rho_0(\ket{i}) = \ket{i}$$ 
            and 
                $$\rho_1(\ket{i}) = \ket{(-1)^i}$$
            with characters 
                $$\chi_0(\ket{i}) = \ket{i} = \begin{bmatrix} 1 & 0\\ 0 & 1\end{bmatrix} \ket{i}$$
            and 
                $$\chi_1(\ket{i}) = \ket{(-1)^i} = \begin{bmatrix} \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}\\ \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}\end{bmatrix} \ket{i}.$$
            Given the standard basis for $\bb{C}^2$ given by $\ket{0}, \ket{1}$, we can apply the fourier transform as follows:

            Recall that the general quantum fourier transform is given by
                $$\cal{F}_G(\ket{g}) = \frac{1}{\sqrt{\abs{G}}} \sum_{\sigma \in \hat{G}} \sqrt{\dim{\sigma}} \sum_{i,j = 1}^{\dim{\sigma}} \sigma(g)_{i,j} \ket{\sigma, i, j}.$$

            We apply this to our basis vectors:
            \begin{align*}
            \cal{F}_G(\ket{0}) &= \frac{1}{\sqrt{2}} \sum_{\sigma \in \hat{\bb{Z}}_2} \sqrt{\dim{\sigma}} \sum_{i,j = 1}^{\dim{\sigma}} \sigma(\ket{0})_{i,j} \ket{\sigma, i, j}\\
            &= \frac{1}{\sqrt{2}} \sum_{\sigma \in \hat{\bb{Z}}_2} \sqrt{2} \sum_{i, j = 1}^2 \sigma(\ket{0}) \ket{\sigma, i, j}\\
            &= \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1}
            \end{align*}
            and
            \begin{align*}
            \cal{F}_G(\ket{1}) &= \frac{1}{\sqrt{2}} \sum_{\sigma \in \hat{\bb{Z}}_2} \sqrt{\dim{\sigma}} \sum_{i,j = 1}^{\dim{\sigma}} \sigma(\ket{1})_{i,j} \ket{\sigma, i, j}\\
            &= \frac{1}{\sqrt{2}} \sum_{\sigma \in \hat{\bb{Z}}_2} \sqrt{2} \sum_{i,j = 1}^2 \sigma(\ket{1})_{i,j} \ket{\sigma, i, j}\\
            &= \frac{1}{\sqrt{2}} \ket{0} - \frac{1}{\sqrt{2}} \ket{1}
            \end{align*}
        \end{example}


\section{The Hidden Subgroup Problem}\label{sec:HSP}
    With the background provided, we are now prepared to discuss the main topic of this report, the hidden subgroup problem (HSP).
    The HSP relies on the concept of a \textit{hiding function} over a group $G$.
    \begin{definition}[Separating Function]\label{def:separating_function}
            We say that a function $f : G \to X$ mapping a group $G$ to a set $X$ \textit{separates cosets} of a subgroup $H$ if for any $g_1, g_2 \in G$ we have $$f(g_1) = f(g_2) \iff g_1 H = g_2 H.$$
        \end{definition}
        With this notion of separating cosets, we can discuss the problem of \textit{hiding} them:
        \begin{problem}[Hidden Subgroup Problem]\label{problem:HSP}
            Given a group $G$, a finite set $X$ and a function $f: G \to X$ that separates cosets of subgroup $H$, use evaluations of $f$ to determine a generating set for $H$.
        \end{problem}
        This problem can be solved classically by evaluating $f(g)$ for every $g \in G$, but this method is incredibly inefficient.
        Quantum algorithms allow this to be computed much more efficiently, as we will see in \hyperref[sec:HSP_algorithms]{Section 4}

    \subsection{The Abelian Hidden Subgroup Problem}\label{HSP:abelian_HSP}
        We begin our discussion of the hidden subgroup problem with abelian groups.
        Abelian groups provide the simplest case of the hidden subgroup problem, since the structure given by the abelian property can be leveraged to simplify the hsp.

        An example of the Hidden Subgroup Problem over abelian groups is the Discrete Logarithm Problem.
        The Discrete Logarithm Problem is described as follows:
        \begin{problem}[Discrete Logarithm Problem]\label{problem:dlp}
            Given a group $g = \bb{Z}_p$ generated by an element $g$, and an element $h = g^r \in G$, determine $r$.
        \end{problem}

        To formulate this in terms of the hidden subgroup problem, we first translate from $\bb{Z}_p$ to the group $\bb{Z}_{p-1} \times \bb{Z}_{p-1}$ with entry-wise multiplication mod $p$.
        The subgroup is given by $H = \{(xr, x) \mid x \in \bb{Z}_{p-1}\}$ where $r$ is the exponent $h = g^r$.
        The function $f$ is given by 
            $$f(x, y) = g^x h^{-y} = g^x g^{-ry} = g^{x - ry}$$ 
        where $g$ is the generator for $G$.
        We now show that $H$ is in fact a subgroup, and that $f$ separates cosets of $H$.
        \begin{theorem}
            the set $H = \{(xr, x) \mid x \in \bb{z}_{p - 1}\}$ is a subgroup of $g = \bb{Z}_{p-1} \times \bb{Z}_{p-1}$.
        \end{theorem}
        \begin{proof}
            $H$ is trivially a non-empty subset of $G$, so it remains only to check that $H$ is a group.

            Let $(sr, s), (tr, t) \in H$.\\
            Notice that $(tr, t)^{-1} = (-tr, -t)$.\\
            This is clearly of the form $(xr, x)$ and hence is an element of $H$, hence $H$ contains inverses for each element.

            Notice also that $(tr, t) \cdot (sr, s) = (tr + sr, t + s) = ((t + s)r, ((t + s))$ which is of the form $(xr, x)$ for $x = (t + s)$, hence $H$ is closed.

            Therefore $H$ is a subgroup of $G$ by the 2-step subgroup test, as wanted.
        \end{proof}
        \begin{theorem}\label{thm:DLP_separating_function}
            $f(x, y) = g^x g^{-ry}$ separates cosets of $H$.
        \end{theorem}
        In order to show this, we first prove a lemma:
        \begin{lemma}\label{lemma:DLP_lemma}
                $f(x, y) = 1 \iff (x, y) \in H$.
        \end{lemma}
        \begin{proof}
                $$\implies$$
                Suppose $f(x,y) = 1$.
                \begin{align*}
                        f(x, y) &= 1\\
                        \iff g^{x - ry} &= 1 & \text{by definition of $f(x, y)$}\\
                        \iff x - ry &= 0 & \text{in $\bb{Z}_p$}\\
                        \iff x &= ry\\
                        \iff (x, y) &= (xr, x)
                \end{align*}
                Hence $(x, y) \in H$.

                $$\impliedby$$
                Suppose $(x, y) \in H$.\\
                Then $(x, y) = (ra, a)$ for some $a \in G$.
                \begin{align*}
                        g^{x - ry} &= g^{ra - ra} & \text{by definition of $f(x, y)$}\\
                        &= g^0 & \text{in $\bb{Z}_p$}\\
                        &= 1
                \end{align*}
                Hence $f(x, y) = 1$.

                Therefore $f(x,y) = 1 \iff (x,y) \in H$, as wanted.
        \end{proof}

        We can now prove theorem \ref{thm:DLP_separating_function}.
        \begin{proof}
                        $$\implies$$
                Suppose $f(a) = f(b)$, where $a = (a_1, a_2), b = (b_1, b_2) \in G$.\\
                Then:
                \begin{align*}
                        f(a) &= f(b)\\
                        g^{a_1 - r a_2} &= g^{b_1 - r b_2} & \text{by definition of $f$}\\
                        g^{a_1 - r a_2 - (b_1 - r b_2)} &= 1\\
                        g^{(a_1 - b_1) - r(a_2 - b_2)} &= 1\\
                        f(a - b) &= 1 & \text{by definition of $f$}
                \end{align*}
                Hence $a - b \in H$ by lemma \ref{lemma:DLP_lemma}.\\
                Since $a - b \in H$, $a + H = b + H$.

                        $$\impliedby$$
                Suppose $a + H = b + H$.\\
                Then $a - b \in H$ and by lemma $f(a - b) = 1$.
                \begin{align*}
                        f(a - b) &= 1\\
                        g^{(a_1 - b_1) - r(a_2 - b_2)} &= 1 & \text{by definition of $f$}\\
                        g^{a_1 - ra_2 - (b_1 - rb_2)} &= 1\\
                        g^{a_1 - ra_2} &= g^{b_1 - r b_2}\\
                        f(a) &= f(b) & \text{by definition of $f$}
                \end{align*}
                
                Therefore $f(a) = f(b) \iff a + H = b + H$, as wanted.
        \end{proof}
        Hence $f$ separates cosets of $H$, and we can see that the discrete logarithm problem is an instance of the hidden subgroup problem.
        The discrete logarithm problem is a key problem used in many important public-key cryptographic systems, for example El-Gamal and the Diffie-Hellman key exchange.
        We can also generalize other problems, such as the period-finding problem and the order finding problem.
        These problems are the foundation of many modern cryptographic systems, and as a generalization of these, solving the HSP efficiently allows us to solve any of these problems efficiently.

\subsection{Algorithms for Solving The Hidden Subgroup Problem}\label{sec:HSP_algorithms}
    %TODO introduce this
    With an understanding of the HSP we can now begin to discuss how we might solve this problem using quantum computing.

    \subsection{The Coset Sampling Method}\label{HSP_algorithms:coset_sampling_method}
        The most common method for solving the HSP is the \textit{Coset Sampling Method}.\\
        The coset sampling method is described in \cite{perepechaenko} as follows:
        Let $G$ be a finite group and $H$ a subgroup hidden by the function $f : G \to X$. Let $\cal{H}$ be a Hilbert space spanned by the elements of $X$ and let $\cal{G}$ be the Hilbert space spanned by elements of $G$.

        Note: We use $\psi_i$ to denote the $i$th state vector of our program. 
        This means that $i$ increases by 1 for each operation applied to our state vector.
        
        \begin{enumerate}
        \item[Step 1:]
            To begin, we prepare two registers. The first register is given by 
                $$\ket{\psi_1} = \frac{1}{\sqrt{\abs{G}}} \sum_{g \in G} \ket{g} \otimes \ket{0}$$
            and contains a uniform superposition of the elements of $G$. 
            The second register is initialized to $\ket{0}$, and later will store states of $\cal{H}$.
            Notice that both registers are represented in our state vector $\psi_i$; the first register is represented by $\ket{g}$ on the left of the tensor product, and the second register is represented by $\ket{0}$ on the right side.

        \item[Step 2:]
            Evaluate $f$ in the second register, producing the state
                $$\ket{\psi_2} = \frac{1}{\sqrt{\abs{G}}} \sum_{g \in G} \ket{g} \otimes \ket{f(g)}.$$

        \item[Step 3:]
            Now measure the second register using the measurement system $\{M_x = \ket{x}\bra{x} \mid x \in X\}$ given by orthogonal projection onto the span of orthonormal basis vectors of $\cal{H}$.
            This yields the outcome $x$ with probability $p_x$.
            We determine $p_x$ as follows:
            \begin{align*}
            p_x &= \norm{I \otimes M_x \left(\frac{1}{\sqrt{\abs{G}}} \sum_{g \in G} \ket{g} \otimes \ket{f(g)}\right)}^2\\
            &= \norm{\frac{1}{\sqrt{\abs{G}}} \sum_{g \in G} \ket{g} \otimes M_x \ket{f(g)}}^2 & \text{distributing the tensor products}\\
            &= \norm{\frac{1}{\sqrt{\abs{G}}} \sum_{g \in G} \ket{g} \otimes \ket{x} \bra{x} \ket{f(g)}}^2 & \text{by definition of $M_x$}
            \end{align*}
            Notice that since $\cal{H}$ is spanned by elements of $X$, we have that an orthonormal basis for $\cal{H}$ is given by elements of $X$, which can be written as $f(g)$ for some $g \in G$ by definition of $X$.
            This gives that 
            \begin{align*}
            p_x &= \norm{\frac{1}{\sqrt{\abs{G}}} \sum_{g \in G, f(g) = x} \ket{g} \otimes \ket{x}}^2\\
            &= \frac{\abs{H}}{\abs{G}}
            \end{align*}
            Of particular interest here is that $p_x$ is independent of $x$.

            If we suppose that $x$ has occurred, then we are left with the state
            \begin{align*}
            \ket{\phi} &= \frac{1}{\sqrt{p_x}} I \otimes M_x \left(\frac{1}{\sqrt{\abs{G}}} \sum_{g \in G} \ket{g} \otimes \ket{f(g)}\right)\\
            &= \frac{\sqrt{\abs{G}}}{\sqrt{\abs{H}}} \frac{1}{\sqrt{\abs{G}}} \sum_{g \in G} \ket{g} \otimes M_x \ket{f(g)} & \text{distributing the tensor product}\\
            &= \frac{1}{\sqrt{\abs{H}}} \sum_{g \in G} \ket{g} \otimes \ket{x} \bra{x} \ket{f(g)} & \text{by definition of $M_x$}\\
            &= \frac{1}{\sqrt{\abs{H}}} \sum_{g \in G, f(g) = x} \ket{g} \otimes \ket{x}
            \end{align*}

            This is the set of all elements of $G$ that map to the value $x$.
            Since $f$ is a hiding function, this means that we have recovered a coset $cH$ of $H$.
            We make this cleared by writing
                $$\ket{\phi} = \frac{1}{\sqrt{\abs{H}}} \sum_{h \in H} \ket{ch} \otimes \ket{x}$$
            This state is a uniform superposition of elements of $cH$, and since $f(ch) = x$ for all $h \in H$ we can abbreviate this:
                $$ \ket{\phi} = \ket{cH} = \frac{1}{\sqrt{\abs{H}}} \sum_{h \in H} \ket{ch}.$$

        \item[Step 4:]
            The last step in this process is left open-ended; there are numerous ways to continue, but the important part of the coset sampling method is to attain the coset state. From here, various different types of measurements can be applied to deduce information about the coset. Some examples include deducing an element of $H$, or a multiple of the order of $H$.
        \end{enumerate}

        The theoretical aspect of this method can be complicated, so we proceed with an example:
        \begin{example}\label{ex:coset_sampling_method}
            Let $G = \bb{Z}_6, H = \{0, 3\}$. We can find the cosets of $H$ are as follows:
            \begin{align*}
                H &= \{0, 3\}\\
                1 + H &= \{1, 4\}\\
                2 + H &= \{2, 5\}
            \end{align*}
            We take the hiding function $f$ to take a coset to the smallest element it contains, i.e. 
            \begin{align*}
                f(H) &= 0\\
                f(1 + H) &= 1\\
                f(2 + H) &= 2
            \end{align*}

            From these definitions we can determine the values mentioned in subsection \cref{HSP_algorithms:coset_sampling_method}, the abstract description of this method.
            We first examine $f$ and notice that $X = \{0, 1, 2\}$.
            We now search for $\cal{G}$ and $\cal{H}$.
            Recall that these are Hilbert spaces spanned by $X$ and $G$ respectively.
            Since $X = \{0, 1, 2\}$ does not represent an orthonormal basis if we were to take this directly to a familiar vector space such as $\bb{R}$, we can either re-define our inner product on this space to generate a reasonable Hilbert space, or more conveniently we can take $\cal{H} = \vspan{X} = \vspan{\ket{0}, \ket{1}, \ket{2}}$.
            Similarly for $\cal{G}$ we can take $\cal{G} = \vspan{G} = \vspan{\ket{0}, \ket{1}, \ket{2}, \ket{3}, \ket{4}, \ket{5}}$.
            In essence, given $X$ and $G$, we take the $i$th element of each to the basis vector $e_i$ in $\cal{H}$ and $\cal{G}$ respectively.
            % TODO include explicit example of non-coset items cancelling out
    
            We proceed to solve this using the coset sampling method.
            As mentioned, step 1 is to create two registers (recall that both registers are represented in a single state, written as a tensor product of the registers).
            In this example, the first state is given by 
                $$\ket{\psi_1} = \frac{1}{\sqrt{6}} \sum_{g \in \bb{Z}_6} \ket{g} \otimes \ket{0}$$
            Next, we evaluate $f$ on the first register and store it in the second.
                $$\ket{\psi_2} = \frac{1}{\sqrt{6}} \sum_{g \in \bb{Z}_6} \ket{g} \otimes \ket{f(g)}$$
            Measuring with respect to the basis of elements of $G$ using $M_x = \ket{x} \bra{x}$ we obtain outcome $x$, giving  
                $$ \ket{\phi} = \frac{1}{\sqrt{2}} \sum_{g \in \bb{Z}_6, f(g) = x} \ket{g} \otimes \ket{x}.$$
            For the sake of this example suppose that $x = 1$.
            Then we can write $\ket{\psi_2}$ explicitly as the superposition
                \begin{align*}
                \ket{\psi_2} &= \frac{1}{\sqrt{6}} \left( \ket{0} \otimes \ket{0} + \ket{1} \otimes \ket{1} + \ket{2} \otimes \ket{2} + \ket{3} \otimes \ket{0} + \ket{4} \otimes \ket {1} + \ket{5} \otimes \ket {2}\right)\\
                \end{align*}
            We then apply our measurement.
            Recall that $p_x = \frac{\abs{H}}{\abs{G}}$, and so we obtain
                \begin{align*}
                \ket{\phi} &= \frac{1}{\sqrt{p_x}} I \otimes M_x \left(\frac{1}{\sqrt{\abs{G}}} \sum_{g \in G} \ket{g} \otimes \ket{f(g)}\right)\\
                &= \frac{\sqrt{6}}{\sqrt{\abs{2}}} \frac{1}{\sqrt{\abs{6}}} \sum_{g \in \bb{Z}_6} \ket{g} \otimes M_x \ket{f(g)} & \text{distributing tensor product}\\
                &= \frac{1}{\sqrt{2}} \sum_{g \in \bb{Z}_6} \ket{g} \otimes \ket{x} \bra{x} \ket{f(g)} & \text{by definition of $M_x$}\\
                &= \begin{aligned}
                    \frac{1}{\sqrt{2}} (&\\
                    &\ket{0} \otimes \ket{1}\bra{1}\ket{0} + \\
                    &\ket{1} \otimes \ket{1}\bra{1}\ket{1} + \\
                    &\ket{2} \otimes \ket{1}\bra{1}\ket{2} + \\
                    &\ket{3} \otimes \ket{1}\bra{1}\ket{0} + \\
                    &\ket{4} \otimes \ket{1}\bra{1}\ket{1} + \\
                    &\ket{5} \otimes \ket{1}\bra{1}\ket{2}
                    )
                    \end{aligned} & \text{expanding the sum}
                \end{align*}
                Recall that $\bra{x}\ket{y} = \inner{x}{y} = 0$ for $x \neq y$ since these are orthogonal basis vectors. This leaves
                $$ \ket{\phi} = \frac{1}{\sqrt{2}} \ket{1} + \frac{1}{\sqrt{2}} \ket{4}$$
            Which is clearly a uniform superposition of a coset of $H$, as expected.
        \end{example}

\section{Non-Abelian HSP}\label{sec:non_abelian_HSP}
    \subsection{Dihedral Groups}\label{non_abelian_HSP:dihedral_group}

        For the sake of this report, we define $D_{2n} = \gen{r, s \mid r^n = s^2 = rsrs = e}$.
        \begin{theorem}
            $D_{2p}$ has $p + 3$ subgroups.
        \end{theorem}
        %TODO elaborate and fill space here
        \begin{example}
            As an example, consider $D_4$.
            Notice that $D_4 = D_{2p}$ with $p = 2$, and hence has $2 + 3 = 5$ subgroups, namely
                $$\gen{e}, \gen{r}, \gen{s}, \gen{rs}, D_4.$$
            Given a hiding function $f$ and a hidden subgroup $H$, we determine $H$ by querying (evaluating $f$ on) $e, r, rs$.
            
            Let $q_1, q_2$ denote two queried elements.
            If $f(q_1) = f(q_2)$ then we have that $q_1, q_2 \in cH$ for some $c$, and hence $q_1^{-1} q_2 \in H$.
            Since we queried generators, we have that $q_1^{-1} q_2$ generates $H$.\\
            If $f(q_1) \neq f(q_2) \neq f(q_3)$ (i.e. they are all distinct) then the cosets of $H$ must separate these elements.\\
            Notice that there is no way to construct cosets of the listed subgroups such that this occurs, other than to separate all elements, i.e. $H$ must be the trivial subgroup $\gen{e}$.

            Hence we have found $H$.
        \end{example}

        We can extend this method to any prime dihedral group $D_{2p}$ with $p \neq 2$ by querying $e, r, r^k s$ for $1 \leq k < p$.
        Formalizing this we have the following theorem:

        \begin{theorem}
            For $G = D_{2p}$ with $p \neq 2$ there exists an algorithm to solve the $HSP$ over $G$ with $\frac{p+5}{2}$ queries.
        \end{theorem}
        The proof of this is provided in \cite{perepechaenko}.

        \begin{theorem}
            If $G = D_{2n}$ and $H \leqslant G$ be a subgroup hidden by the function $f : G \to X$. Then $f\mid_{C_n} : C_n \to X$ hides $H \cap C_n$.
        \end{theorem}
        \begin{proof}
            Let $a, b \in C_n$ such that $f(a) = f(b)$.\\
            Then $aH = bH \implies ab^{-1} \in H$.\\
            Since $a, b \in C_n$, by closure we have $ab^{-1} \in C_n$.\\
            Hence $ab^{-1} \in C_n \cap H$.

            Suppose $a(H \cap C_n) = b(H \cap C_n)$.\\
            Then $ab^{-1} \in H \cap C_n \implies ab^{-1} \in H$ and $ab^{-1} \in C_n$.\\
            By closure of $C_n$ this gives that $a, b \in C_n$.\\
            Notice that $ab^{-1} \in H \implies ab^{-1}H = H \implies aH = bH$, hence $f(a) = f(b)$.

            Therefore $f(a) = f(b) \iff a(H \cap C_n) = b(H \cap C_n)$, as wanted.
        \end{proof}

        This result permits us to study the dihedral HSP in terms of cyclic groups, meaning that we can apply the coset sampling method and the abelian QFT in order to gain information about $H$ and $f$.

\newpage
\nocite{*}
\printbibliography
\end{document}

